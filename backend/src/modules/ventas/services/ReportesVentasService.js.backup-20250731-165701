// ============================================
// REPORTES VENTAS SERVICE - ANALYTICS EMPRESARIAL AVANZADO
// Sistema CRM/ERP v2.0 - Módulo de Ventas
// ============================================

const { query } = require('../../../config/database');
const ExcelJS = require('exceljs');
const PDFDocument = require('pdfkit');

class ReportesVentasService {

    // ==========================================
    // REPORTES EJECUTIVOS PRINCIPALES
    // ==========================================
    
    static async generarReporteEjecutivo(params) {
        try {
            const {
                fecha_desde,
                fecha_hasta,
                asesor_id,
                equipo_id,
                formato = 'json',
                incluir_graficos = true
            } = params;
            
            const reporte = {
                metadata: {
                    titulo: 'Reporte Ejecutivo de Ventas',
                    periodo: { desde: fecha_desde, hasta: fecha_hasta },
                    fecha_generacion: new Date().toISOString(),
                    parametros: params
                },
                resumen_ejecutivo: await this._generarResumenEjecutivo(params),
                metricas_clave: await this._generarMetricasClave(params),
                analisis_pipeline: await this._generarAnalisisPipeline(params),
                rendimiento_asesores: await this._generarRendimientoAsesores(params),
                analisis_productos: await this._generarAnalisisProductos(params),
                tendencias_temporales: await this._generarTendenciasTemporales(params),
                conversion_metrics: await this._generarMetricasConversion(params),
                alertas_recomendaciones: await this._generarAlertasRecomendaciones(params)
            };
            
            if (incluir_graficos) {
                reporte.graficos = await this._generarDatosGraficos(params);
            }
            
            // Generar archivo según formato solicitado
            switch (formato) {
                case 'excel':
                    return await this._exportarReporteExcel(reporte);
                case 'pdf':
                    return await this._exportarReportePDF(reporte);
                default:
                    return reporte;
            }
            
        } catch (error) {
            console.error('Error generando reporte ejecutivo:', error);
            throw error;
        }
    }
    
    static async generarReportePipeline(params) {
        try {
            const {
                fecha_desde,
                fecha_hasta,
                asesor_id,
                incluir_proyecciones = true
            } = params;
            
            let whereConditions = ['v.eliminado = false'];
            let queryParams = [];
            
            if (fecha_desde) {
                whereConditions.push('v.fecha_creacion >= ?');
                queryParams.push(fecha_desde);
            }
            
            if (fecha_hasta) {
                whereConditions.push('v.fecha_creacion <= ?');
                queryParams.push(fecha_hasta);
            }
            
            if (asesor_id) {
                whereConditions.push('v.asesor_id = ?');
                queryParams.push(asesor_id);
            }
            
            // Estado actual del pipeline
            const [estadoPipeline] = await query.execute(
                `SELECT 
                    v.estado,
                    COUNT(*) as cantidad_ventas,
                    SUM(v.valor_total) as valor_total,
                    AVG(v.valor_total) as valor_promedio,
                    AVG(DATEDIFF(NOW(), v.fecha_creacion)) as dias_promedio_estado
                 FROM ventas v
                 WHERE ${whereConditions.join(' AND ')}
                 GROUP BY v.estado
                 ORDER BY 
                    CASE v.estado 
                        WHEN 'Prospecto' THEN 1
                        WHEN 'Contactado' THEN 2  
                        WHEN 'Interesado' THEN 3
                        WHEN 'Cotizado' THEN 4
                        WHEN 'Negociacion' THEN 5
                        WHEN 'Aprobada' THEN 6
                        WHEN 'Facturada' THEN 7
                        WHEN 'Entregada' THEN 8
                        WHEN 'Cancelada' THEN 9
                    END`,
                queryParams
            );
            
            // Análisis de conversión entre estados
            const [conversionEstados] = await query.execute(
                `SELECT 
                    estado_anterior,
                    estado_actual,
                    COUNT(*) as transiciones,
                    AVG(dias_entre_estados) as dias_promedio
                 FROM (
                    SELECT 
                        v.id,
                        v.estado as estado_actual,
                        LAG(v.estado) OVER (PARTITION BY v.id ORDER BY v.fecha_actualizacion) as estado_anterior,
                        DATEDIFF(v.fecha_actualizacion, LAG(v.fecha_actualizacion) OVER (PARTITION BY v.id ORDER BY v.fecha_actualizacion)) as dias_entre_estados
                    FROM ventas v
                    WHERE ${whereConditions.join(' AND ')}
                 ) conversion_data
                 WHERE estado_anterior IS NOT NULL
                 GROUP BY estado_anterior, estado_actual`,
                queryParams
            );
            
            // Velocity del pipeline (tiempo promedio para cerrar)
            const [velocityPipeline] = await query.execute(
                `SELECT 
                    AVG(DATEDIFF(fecha_cierre, fecha_creacion)) as dias_promedio_cierre,
                    MIN(DATEDIFF(fecha_cierre, fecha_creacion)) as dias_minimo_cierre,
                    MAX(DATEDIFF(fecha_cierre, fecha_creacion)) as dias_maximo_cierre,
                    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY DATEDIFF(fecha_cierre, fecha_creacion)) as mediana_dias_cierre
                 FROM ventas v
                 WHERE ${whereConditions.join(' AND ')}
                   AND v.estado IN ('Facturada', 'Entregada')
                   AND v.fecha_cierre IS NOT NULL`,
                queryParams
            );
            
            let proyecciones = null;
            if (incluir_proyecciones) {
                proyecciones = await this._calcularProyeccionesPipeline(queryParams, whereConditions);
            }
            
            return {
                metadata: {
                    titulo: 'Análisis de Pipeline de Ventas',
                    fecha_generacion: new Date().toISOString(),
                    parametros: params
                },
                estado_pipeline: estadoPipeline,
                conversion_estados: conversionEstados,
                velocity_pipeline: velocityPipeline[0],
                proyecciones: proyecciones,
                valor_total_pipeline: estadoPipeline.reduce((sum, estado) => sum + parseFloat(estado.valor_total), 0),
                cantidad_total_pipeline: estadoPipeline.reduce((sum, estado) => sum + parseInt(estado.cantidad_ventas), 0)
            };
            
        } catch (error) {
            console.error('Error generando reporte de pipeline:', error);
            throw error;
        }
    }
    
    static async generarReporteComisiones(params) {
        try {
            const {
                fecha_desde,
                fecha_hasta,
                asesor_id,
                estado_comision = 'all'
            } = params;
            
            let whereConditions = ['c.eliminado = false'];
            let queryParams = [];
            
            if (fecha_desde) {
                whereConditions.push('c.fecha_calculo >= ?');
                queryParams.push(fecha_desde);
            }
            
            if (fecha_hasta) {
                whereConditions.push('c.fecha_calculo <= ?');
                queryParams.push(fecha_hasta);
            }
            
            if (asesor_id) {
                whereConditions.push('c.asesor_id = ?');
                queryParams.push(asesor_id);
            }
            
            if (estado_comision !== 'all') {
                whereConditions.push('c.estado = ?');
                queryParams.push(estado_comision);
            }
            
            // Resumen de comisiones por asesor
            const [comisionesPorAsesor] = await query.execute(
                `SELECT 
                    u.nombre_completo as asesor,
                    c.asesor_id,
                    COUNT(*) as total_comisiones,
                    SUM(c.monto_comision) as total_monto,
                    AVG(c.porcentaje_comision) as porcentaje_promedio,
                    SUM(CASE WHEN c.estado = 'Pagada' THEN c.monto_comision ELSE 0 END) as monto_pagado,
                    SUM(CASE WHEN c.estado = 'Pendiente' THEN c.monto_comision ELSE 0 END) as monto_pendiente,
                    MIN(c.fecha_calculo) as primera_comision,
                    MAX(c.fecha_calculo) as ultima_comision
                 FROM comisiones c
                 JOIN usuarios u ON c.asesor_id = u.id
                 WHERE ${whereConditions.join(' AND ')}
                 GROUP BY c.asesor_id, u.nombre_completo
                 ORDER BY total_monto DESC`,
                queryParams
            );
            
            // Evolución mensual de comisiones
            const [evolucionMensual] = await query.execute(
                `SELECT 
                    DATE_FORMAT(c.fecha_calculo, '%Y-%m') as mes,
                    COUNT(*) as cantidad_comisiones,
                    SUM(c.monto_comision) as total_monto,
                    AVG(c.monto_comision) as promedio_monto,
                    COUNT(DISTINCT c.asesor_id) as asesores_activos
                 FROM comisiones c
                 WHERE ${whereConditions.join(' AND ')}
                 GROUP BY DATE_FORMAT(c.fecha_calculo, '%Y-%m')
                 ORDER BY mes DESC
                 LIMIT 12`,
                queryParams
            );
            
            // Top 10 comisiones más altas
            const [topComisiones] = await query.execute(
                `SELECT 
                    c.*,
                    u.nombre_completo as asesor,
                    v.codigo_venta,
                    v.cliente_nombre,
                    v.valor_total as valor_venta
                 FROM comisiones c
                 JOIN usuarios u ON c.asesor_id = u.id
                 JOIN ventas v ON c.venta_id = v.id
                 WHERE ${whereConditions.join(' AND ')}
                 ORDER BY c.monto_comision DESC
                 LIMIT 10`,
                queryParams
            );
            
            // Estadísticas generales
            const [estadisticasGenerales] = await query.execute(
                `SELECT 
                    COUNT(*) as total_comisiones,
                    SUM(c.monto_comision) as monto_total,
                    AVG(c.monto_comision) as promedio_comision,
                    AVG(c.porcentaje_comision) as porcentaje_promedio,
                    COUNT(DISTINCT c.asesor_id) as asesores_con_comisiones,
                    SUM(CASE WHEN c.estado = 'Pagada' THEN 1 ELSE 0 END) as comisiones_pagadas,
                    SUM(CASE WHEN c.estado = 'Pendiente' THEN 1 ELSE 0 END) as comisiones_pendientes
                 FROM comisiones c
                 WHERE ${whereConditions.join(' AND ')}`,
                queryParams
            );
            
            return {
                metadata: {
                    titulo: 'Reporte de Comisiones',
                    fecha_generacion: new Date().toISOString(),
                    parametros: params
                },
                estadisticas_generales: estadisticasGenerales[0],
                comisiones_por_asesor: comisionesPorAsesor,
                evolucion_mensual: evolucionMensual,
                top_comisiones: topComisiones
            };
            
        } catch (error) {
            console.error('Error generando reporte de comisiones:', error);
            throw error;
        }
    }

    // ==========================================
    // ANÁLISIS AVANZADOS Y PREDICTIVOS
    // ==========================================
    
    static async generarAnalisisPredictivo(params) {
        try {
            const { asesor_id, meses_historicos = 6 } = params;
            
            // Datos históricos para análisis de tendencias
            const [datosHistoricos] = await query.execute(
                `SELECT 
                    DATE_FORMAT(fecha_creacion, '%Y-%m') as mes,
                    COUNT(*) as cantidad_ventas,
                    SUM(valor_total) as valor_total,
                    AVG(valor_total) as valor_promedio,
                    COUNT(DISTINCT asesor_id) as asesores_activos
                 FROM ventas
                 WHERE eliminado = false
                   AND fecha_creacion >= DATE_SUB(NOW(), INTERVAL ? MONTH)
                   ${asesor_id ? 'AND asesor_id = ?' : ''}
                 GROUP BY DATE_FORMAT(fecha_creacion, '%Y-%m')
                 ORDER BY mes`,
                asesor_id ? [meses_historicos, asesor_id] : [meses_historicos]
            );
            
            // Calcular tendencias usando regresión lineal simple
            const tendencias = this._calcularTendencias(datosHistoricos);
            
            // Proyección para próximos 3 meses
            const proyecciones = this._calcularProyecciones(datosHistoricos, tendencias, 3);
            
            // Análisis de estacionalidad
            const estacionalidad = await this._analizarEstacionalidad(params);
            
            // Factores de riesgo
            const factoresRiesgo = await this._identificarFactoresRiesgo(params);
            
            return {
                metadata: {
                    titulo: 'Análisis Predictivo de Ventas',
                    fecha_generacion: new Date().toISOString(),
                    meses_analizados: meses_historicos
                },
                datos_historicos: datosHistoricos,
                tendencias: tendencias,
                proyecciones: proyecciones,
                estacionalidad: estacionalidad,
                factores_riesgo: factoresRiesgo,
                confiabilidad: this._calcularConfiabilidad(datosHistoricos)
            };
            
        } catch (error) {
            console.error('Error generando análisis predictivo:', error);
            throw error;
        }
    }
    
    static async generarAnalisisCompetitivo(params) {
        try {
            const { periodo = 'mensual', incluir_benchmarks = true } = params;
            
            // Análisis de productos más vendidos
            const [productosTop] = await query.execute(
                `SELECT 
                    p.nombre as producto,
                    p.categoria,
                    COUNT(*) as ventas_cantidad,
                    SUM(v.valor_total) as ventas_valor,
                    AVG(v.valor_total) as precio_promedio,
                    AVG(v.margen_ganancia) as margen_promedio
                 FROM ventas v
                 JOIN productos p ON v.producto_id = p.id
                 WHERE v.eliminado = false
                   AND v.estado NOT IN ('Cancelada')
                   AND v.fecha_creacion >= DATE_SUB(NOW(), INTERVAL 3 MONTH)
                 GROUP BY p.id, p.nombre, p.categoria
                 ORDER BY ventas_valor DESC
                 LIMIT 20`
            );
            
            // Análisis de márgenes por categoría
            const [margenCategoria] = await query.execute(
                `SELECT 
                    p.categoria,
                    COUNT(*) as ventas_cantidad,
                    AVG(v.margen_ganancia) as margen_promedio,
                    MIN(v.margen_ganancia) as margen_minimo,
                    MAX(v.margen_ganancia) as margen_maximo,
                    SUM(v.valor_total) as ventas_totales
                 FROM ventas v
                 JOIN productos p ON v.producto_id = p.id
                 WHERE v.eliminado = false
                   AND v.estado NOT IN ('Cancelada')
                   AND v.fecha_creacion >= DATE_SUB(NOW(), INTERVAL 3 MONTH)
                 GROUP BY p.categoria
                 ORDER BY margen_promedio DESC`
            );
            
            // Análisis de precios competitivos
            const competitividadPrecios = await this._analizarCompetitividadPrecios(productosTop);
            
            let benchmarks = null;
            if (incluir_benchmarks) {
                benchmarks = await this._obtenerBenchmarksIndustria();
            }
            
            return {
                metadata: {
                    titulo: 'Análisis Competitivo',
                    fecha_generacion: new Date().toISOString(),
                    periodo_analizado: periodo
                },
                productos_top: productosTop,
                margen_por_categoria: margenCategoria,
                competitividad_precios: competitividadPrecios,
                benchmarks_industria: benchmarks,
                recomendaciones: this._generarRecomendacionesCompetitivas(productosTop, margenCategoria)
            };
            
        } catch (error) {
            console.error('Error generando análisis competitivo:', error);
            throw error;
        }
    }

    // ==========================================
    // EXPORTACIÓN DE REPORTES
    // ==========================================
    
    static async _exportarReporteExcel(reporte) {
        const workbook = new ExcelJS.Workbook();
        
        // Hoja de resumen ejecutivo
        const resumenSheet = workbook.addWorksheet('Resumen Ejecutivo');
        
        // Configurar estilos
        const headerStyle = {
            font: { bold: true, color: { argb: 'FFFFFF' } },
            fill: { type: 'pattern', pattern: 'solid', fgColor: { argb: '366092' } },
            alignment: { horizontal: 'center' }
        };
        
        // Agregar título
        resumenSheet.mergeCells('A1:F1');
        resumenSheet.getCell('A1').value = reporte.metadata.titulo;
        resumenSheet.getCell('A1').style = {
            font: { bold: true, size: 16 },
            alignment: { horizontal: 'center' }
        };
        
        // Agregar métricas clave
        let row = 3;
        resumenSheet.getCell(`A${row}`).value = 'Métricas Clave';
        resumenSheet.getCell(`A${row}`).style = headerStyle;
        
        row++;
        for (const [key, value] of Object.entries(reporte.metricas_clave)) {
            resumenSheet.getCell(`A${row}`).value = this._formatearNombreMetrica(key);
            resumenSheet.getCell(`B${row}`).value = value;
            row++;
        }
        
        // Hoja de análisis de pipeline
        if (reporte.analisis_pipeline) {
            const pipelineSheet = workbook.addWorksheet('Pipeline');
            this._agregarDatosPipeline(pipelineSheet, reporte.analisis_pipeline);
        }
        
        // Hoja de rendimiento de asesores
        if (reporte.rendimiento_asesores && reporte.rendimiento_asesores.length > 0) {
            const asesoresSheet = workbook.addWorksheet('Asesores');
            this._agregarDatosAsesores(asesoresSheet, reporte.rendimiento_asesores);
        }
        
        // Generar buffer del archivo
        const buffer = await workbook.xlsx.writeBuffer();
        
        return {
            tipo: 'excel',
            nombre_archivo: `reporte_ventas_${new Date().toISOString().split('T')[0]}.xlsx`,
            buffer: buffer,
            size: buffer.length
        };
    }
    
    static async _exportarReportePDF(reporte) {
        return new Promise((resolve, reject) => {
            try {
                const doc = new PDFDocument({ margin: 50 });
                const chunks = [];
                
                doc.on('data', chunk => chunks.push(chunk));
                doc.on('end', () => {
                    const buffer = Buffer.concat(chunks);
                    resolve({
                        tipo: 'pdf',
                        nombre_archivo: `reporte_ventas_${new Date().toISOString().split('T')[0]}.pdf`,
                        buffer: buffer,
                        size: buffer.length
                    });
                });
                
                // Configurar fuentes y estilos
                doc.fontSize(20).text(reporte.metadata.titulo, { align: 'center' });
                doc.moveDown();
                
                // Fecha de generación
                doc.fontSize(10).text(`Generado el: ${new Date(reporte.metadata.fecha_generacion).toLocaleString()}`, { align: 'right' });
                doc.moveDown();
                
                // Resumen ejecutivo
                if (reporte.resumen_ejecutivo) {
                    doc.fontSize(16).text('Resumen Ejecutivo', { underline: true });
                    doc.moveDown();
                    doc.fontSize(12).text(reporte.resumen_ejecutivo.descripcion || 'Análisis del período especificado');
                    doc.moveDown();
                }
                
                // Métricas clave
                if (reporte.metricas_clave) {
                    doc.fontSize(14).text('Métricas Principales', { underline: true });
                    doc.moveDown();
                    
                    for (const [key, value] of Object.entries(reporte.metricas_clave)) {
                        doc.fontSize(11).text(`${this._formatearNombreMetrica(key)}: ${this._formatearValorMetrica(key, value)}`);
                    }
                    doc.moveDown();
                }
                
                // Finalizar documento
                doc.end();
                
            } catch (error) {
                reject(error);
            }
        });
    }

    // ==========================================
    // MÉTODOS AUXILIARES PARA CÁLCULOS
    // ==========================================
    
    static async _generarResumenEjecutivo(params) {
        const [resumen] = await query.execute(
            `SELECT 
                COUNT(*) as total_ventas,
                SUM(valor_total) as valor_total,
                AVG(valor_total) as valor_promedio,
                COUNT(DISTINCT asesor_id) as asesores_activos,
                SUM(CASE WHEN estado = 'Facturada' THEN 1 ELSE 0 END) as ventas_facturadas,
                SUM(CASE WHEN estado = 'Cancelada' THEN 1 ELSE 0 END) as ventas_canceladas
             FROM ventas 
             WHERE eliminado = false
               ${params.fecha_desde ? 'AND fecha_creacion >= ?' : ''}
               ${params.fecha_hasta ? 'AND fecha_creacion <= ?' : ''}
               ${params.asesor_id ? 'AND asesor_id = ?' : ''}`,
            [params.fecha_desde, params.fecha_hasta, params.asesor_id].filter(Boolean)
        );
        
        return resumen[0];
    }
    
    static async _generarMetricasClave(params) {
        const resumen = await this._generarResumenEjecutivo(params);
        
        return {
            total_ventas: resumen.total_ventas,
            valor_total: resumen.valor_total,
            valor_promedio: resumen.valor_promedio,
            tasa_conversion: (resumen.ventas_facturadas / resumen.total_ventas * 100).toFixed(2) + '%',
            tasa_cancelacion: (resumen.ventas_canceladas / resumen.total_ventas * 100).toFixed(2) + '%',
            asesores_activos: resumen.asesores_activos
        };
    }
    
    static _calcularTendencias(datosHistoricos) {
        if (datosHistoricos.length < 2) return null;
        
        const n = datosHistoricos.length;
        let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
        
        datosHistoricos.forEach((data, index) => {
            const x = index + 1;
            const y = parseFloat(data.valor_total);
            sumX += x;
            sumY += y;
            sumXY += x * y;
            sumX2 += x * x;
        });
        
        const pendiente = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        const intercepto = (sumY - pendiente * sumX) / n;
        
        return {
            pendiente: pendiente,
            intercepto: intercepto,
            tendencia: pendiente > 0 ? 'creciente' : pendiente < 0 ? 'decreciente' : 'estable',
            confiabilidad: this._calcularR2(datosHistoricos, pendiente, intercepto)
        };
    }
    
    static _formatearNombreMetrica(key) {
        const nombres = {
            total_ventas: 'Total de Ventas',
            valor_total: 'Valor Total',
            valor_promedio: 'Valor Promedio',
            tasa_conversion: 'Tasa de Conversión',
            tasa_cancelacion: 'Tasa de Cancelación',
            asesores_activos: 'Asesores Activos'
        };
        
        return nombres[key] || key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
    }
    
    static _formatearValorMetrica(key, value) {
        if (key.includes('valor') || key.includes('total')) {
            return new Intl.NumberFormat('es-CO', {
                style: 'currency',
                currency: 'COP',
                minimumFractionDigits: 0
            }).format(value).replace('COP', '').trim();
        }
        
        if (key.includes('tasa') || key.includes('porcentaje')) {
            return value + (typeof value === 'string' && value.includes('%') ? '' : '%');
        }
        
        return value?.toLocaleString ? value.toLocaleString() : value;
    }
}

module.exports = ReportesVentasService;