const jwt = require('jsonwebtoken');
const { createClient } = require('@supabase/supabase-js');
const winston = require('winston');

const supabase = createClient(process.env.SUPABASE_URL, process.env.SUPABASE_ANON_KEY);

const logger = winston.createLogger({
    level: process.env.LOG_LEVEL || 'info',
    format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.json()
    ),
    transports: [
        new winston.transports.Console(),
        new winston.transports.File({ filename: 'logs/auth.log' })
    ]
});

const authenticateToken = async (req, res, next) => {
    const correlationId = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
    
    try {
        const authHeader = req.headers['authorization'];
        const token = authHeader && authHeader.split(' ')[1];
        
        if (!token) {
            logger.warn('Intento de acceso sin token', {
                correlation_id: correlationId,
                endpoint: req.path,
                ip: req.ip
            });
            
            return res.status(401).json({
                success: false,
                error: 'Token de acceso requerido',
                code: 'NO_TOKEN',
                correlation_id: correlationId
            });
        }

        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        
        const { data: usuario, error } = await supabase
            .from('usuarios')
            .select('id, nombre, apellido, email, rol_id, activo')
            .eq('id', decoded.user_id)
            .eq('activo', true)
            .single();

        if (error || !usuario) {
            logger.warn('Usuario no vÃ¡lido o inactivo', {
                correlation_id: correlationId,
                user_id: decoded.user_id,
                endpoint: req.path,
                error: error?.message
            });

            return res.status(403).json({
                success: false,
                error: 'Usuario no vÃ¡lido o inactivo',
                code: 'INVALID_USER',
                correlation_id: correlationId
            });
        }

        req.user = {
            id: usuario.id,
            user_id: decoded.user_id, // AGREGANDO AMBOS CAMPOS
            nombre: usuario.nombre,
            apellido: usuario.apellido,
            email: usuario.email,
            rol: usuario.rol,
            nombre_completo: usuario.nombre + ' ' + usuario.apellido
        };

        logger.info('Usuario autenticado exitosamente', {
            correlation_id: correlationId,
            user_id: usuario.id,
            action: 'authenticate',
            endpoint: req.path
        });

        next();

    } catch (error) {
        logger.error('Error crÃ­tico de autenticaciÃ³n', {
            correlation_id: correlationId,
            error: error.message,
            endpoint: req.path
        });

        if (error.name === 'JsonWebTokenError') {
            return res.status(403).json({
                success: false,
                error: 'Token invÃ¡lido',
                code: 'INVALID_TOKEN',
                correlation_id: correlationId
            });
        }

        if (error.name === 'TokenExpiredError') {
            return res.status(403).json({
                success: false,
                error: 'Token expirado. Inicie sesiÃ³n nuevamente',
                code: 'EXPIRED_TOKEN',
                correlation_id: correlationId
            });
        }

        return res.status(500).json({
            success: false,
            error: 'Error interno de autenticaciÃ³n',
            code: 'AUTH_ERROR',
            correlation_id: correlationId
        });
    }
};

const requireRole = (rolesPermitidos) => {
    if (!Array.isArray(rolesPermitidos)) {
        rolesPermitidos = [rolesPermitidos];
    }
    
    return (req, res, next) => {
        const correlationId = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        
        if (!req.user) {
            return res.status(401).json({
                success: false,
                error: 'Usuario no autenticado',
                code: 'NOT_AUTHENTICATED',
                correlation_id: correlationId
            });
        }

        if (!rolesPermitidos.includes(req.user.rol)) {
            logger.warn('Acceso denegado por rol insuficiente', {
                correlation_id: correlationId,
                user_id: req.user.id,
                rol_actual: req.user.rol,
                roles_requeridos: rolesPermitidos
            });
            
            return res.status(403).json({
                success: false,
                error: 'Permisos insuficientes para esta operaciÃ³n',
                code: 'INSUFFICIENT_PERMISSIONS',
                rol_requerido: rolesPermitidos,
                rol_actual: req.user.rol,
                correlation_id: correlationId
            });
        }

        next();
    };
};

const requireOwnership = (req, res, next) => {
    // Permitir acceso total a admins y supervisores
    const userRole = req.user.rol?.nombre || req.user.rol;
    
    if (['admin', 'supervisor', 'ADMIN', 'SUPER_ADMIN', 'SUPERVISOR'].includes(userRole)) {
        console.log('âœ… Admin/Supervisor access granted:', userRole);
        return next();
    }

    // Obtener ID del usuario del JWT (puede ser user_id o id)
    const currentUserId = req.user.user_id || req.user.id;
    
    // Obtener ID solicitado de diferentes fuentes posibles
    const {
        asesorId,          // Para rutas de prospectos: /prospectos/:asesorId
        usuarioId,         // Para rutas de notificaciones: /notificaciones/:usuarioId
        userId,            // Para otras rutas: /users/:userId
        id                 // Para rutas generales: /:id
    } = req.params;
    
    const asesorIdQuery = req.query.asesor_id;
    const userIdQuery = req.query.user_id;
    
    // Determinar quÃ© ID se estÃ¡ solicitando
    const requestedId = asesorId || usuarioId || userId || id;
    const requestedIdFromQuery = asesorIdQuery || userIdQuery;
    
    console.log('ðŸ” Ownership validation:', {
        currentUserId,
        requestedId,
        requestedIdFromQuery,
        userRole,
        params: req.params,
        query: req.query
    });
    
    // Validar ownership para parÃ¡metros de ruta
    if (requestedId && requestedId !== 'todos') {
        if (parseInt(requestedId) !== currentUserId) {
            console.log('âŒ Ownership denied - Route parameter mismatch');
            return res.status(403).json({
                success: false,
                error: 'No tienes permisos para realizar esta acciÃ³n.',
                code: 'OWNERSHIP_REQUIRED',
                details: 'Solo puedes acceder a tu propia informaciÃ³n'
            });
        }
    }
    
    // Validar ownership para parÃ¡metros de query
    if (requestedIdFromQuery && parseInt(requestedIdFromQuery) !== currentUserId) {
        console.log('âŒ Ownership denied - Query parameter mismatch');
        return res.status(403).json({
            success: false,
            error: 'No tienes permisos para realizar esta acciÃ³n.',
            code: 'OWNERSHIP_REQUIRED',
            details: 'Solo puedes acceder a tu propia informaciÃ³n'
        });
    }
    
    console.log('âœ… Ownership validation passed');
    next();
};

// âœ… EXPORTS
module.exports = {
    authenticateToken,
    requireRole,
    requireOwnership
};
