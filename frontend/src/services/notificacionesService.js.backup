// frontend/src/services/notificacionesService.js
const API_BASE = 'http://localhost:3001/api';

class NotificacionesService {
    
    constructor() {
        console.log('üîî Servicio de notificaciones inicializado');
        // ‚úÖ NUEVO: Cache para optimizar performance
        this.cache = new Map();
        this.cacheTimeout = 30000; // 30 segundos
    }

    // ‚úÖ NUEVO: M√©todo auxiliar para headers con authentication
    getHeaders() {
        const token = localStorage.getItem('token');
        return {
            'Content-Type': 'application/json',
            // ‚úÖ FIJO CR√çTICO: Authentication habilitada
            ...(token && { 'Authorization': `Bearer ${token}` })
        };
    }

    // ‚úÖ NUEVO: Error handling robusto
    async handleError(response, endpoint) {
        if (!response.ok) {
            // Manejo espec√≠fico por c√≥digo de error
            switch (response.status) {
                case 401:
                    console.warn('üö´ Token expirado o inv√°lido');
                    localStorage.removeItem('token');
                    throw new Error('Sesi√≥n expirada. Inicia sesi√≥n nuevamente.');
                
                case 403:
                    throw new Error('No tienes permisos para realizar esta acci√≥n.');
                
                case 429:
                    throw new Error('Demasiadas solicitudes. Espera un momento.');
                
                case 500:
                    throw new Error('Error interno del servidor. Intenta m√°s tarde.');
                
                default:
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
        }
        return await response.json();
    }

    async obtenerNotificaciones(limite = 20, soloNoLeidas = false) {
        // ‚úÖ NUEVO: Cache para requests frecuentes
        const cacheKey = `notificaciones_${limite}_${soloNoLeidas}`;
        
        if (this.cache.has(cacheKey)) {
            const cached = this.cache.get(cacheKey);
            if (Date.now() - cached.timestamp < this.cacheTimeout) {
                console.log('üì¶ Usando notificaciones desde cache');
                return cached.data;
            }
        }

        try {
            console.log(`üì° Obteniendo notificaciones: limite=${limite}, soloNoLeidas=${soloNoLeidas}`);
            
            const response = await fetch(
                `${API_BASE}/notificaciones/1?limite=${limite}&solo_no_leidas=${soloNoLeidas}`,
                {
                    method: 'GET',
                    headers: this.getHeaders() // ‚úÖ FIJO: Headers con auth
                }
            );

            const data = await this.handleError(response, 'obtenerNotificaciones');
            console.log(`‚úÖ Notificaciones obtenidas:`, data);
            
            // ‚úÖ NUEVO: Guardar en cache
            this.cache.set(cacheKey, {
                data,
                timestamp: Date.now()
            });
            
            return data;
        } catch (error) {
            console.error('‚ùå Error obteniendo notificaciones:', error);
            return { 
                success: false, 
                data: [], 
                total_no_leidas: 0,
                error: error.message 
            };
        }
    }

    async obtenerContador() {
        try {
            console.log('üì° Obteniendo contador de notificaciones...');
            
            const response = await fetch(`${API_BASE}/notificaciones/contador/1`, {
                method: 'GET',
                headers: this.getHeaders() // ‚úÖ FIJO: Headers con auth
            });

            const data = await this.handleError(response, 'obtenerContador');
            console.log(`‚úÖ Contador obtenido:`, data);
            
            return data;
        } catch (error) {
            console.error('‚ùå Error obteniendo contador:', error);
            return { 
                success: false, 
                contador: 0,
                error: error.message 
            };
        }
    }

    async marcarLeida(id) {
        try {
            console.log(`üì° Marcando notificaci√≥n ${id} como le√≠da...`);
            
            // ‚úÖ FIJO: Cambio a PATCH seg√∫n backend optimizado
            const response = await fetch(`${API_BASE}/notificaciones/${id}/leida`, {
                method: 'PATCH',
                headers: this.getHeaders() // ‚úÖ FIJO: Headers con auth
            });

            const data = await this.handleError(response, 'marcarLeida');
            console.log(`‚úÖ Notificaci√≥n ${id} marcada como le√≠da:`, data);
            
            // ‚úÖ NUEVO: Limpiar cache relacionado
            this.clearRelatedCache();
            
            return data;
        } catch (error) {
            console.error(`‚ùå Error marcando notificaci√≥n ${id} como le√≠da:`, error);
            return { 
                success: false,
                error: error.message 
            };
        }
    }

    async marcarTodasLeidas() {
        try {
            console.log('üì° Marcando todas las notificaciones como le√≠das...');
            
            // ‚úÖ FIJO: Cambio a PATCH seg√∫n backend optimizado
            const response = await fetch(`${API_BASE}/notificaciones/marcar-todas-leidas/1`, {
                method: 'PATCH',
                headers: this.getHeaders() // ‚úÖ FIJO: Headers con auth
            });

            const data = await this.handleError(response, 'marcarTodasLeidas');
            console.log('‚úÖ Todas las notificaciones marcadas como le√≠das:', data);
            
            // ‚úÖ NUEVO: Limpiar todo el cache
            this.clearCache();
            
            return data;
        } catch (error) {
            console.error('‚ùå Error marcando todas como le√≠das:', error);
            return { 
                success: false,
                error: error.message 
            };
        }
    }

    async testConexion() {
        try {
            console.log('üîç Testeando conexi√≥n con API...');
            
            // ‚úÖ NUEVO: Timeout para test de conexi√≥n
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 5000);
            
            const response = await fetch(`${API_BASE}/notificaciones/health`, {
                method: 'GET',
                headers: this.getHeaders(),
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            const data = await this.handleError(response, 'testConexion');
            console.log('‚úÖ Test de conexi√≥n exitoso:', data);
            
            return data;
        } catch (error) {
            if (error.name === 'AbortError') {
                console.error('‚ùå Timeout en test de conexi√≥n');
                return { 
                    success: false,
                    error: 'Timeout de conexi√≥n' 
                };
            }
            
            console.error('‚ùå Error en test de conexi√≥n:', error);
            return { 
                success: false,
                error: error.message 
            };
        }
    }

    // ‚úÖ NUEVOS: M√©todos de cache para performance
    clearCache() {
        this.cache.clear();
        console.log('üóëÔ∏è Cache de notificaciones limpiado');
    }

    clearRelatedCache() {
        for (const key of this.cache.keys()) {
            if (key.startsWith('notificaciones_')) {
                this.cache.delete(key);
            }
        }
    }

    // ‚úÖ NUEVOS: M√©todos de utilidad para el frontend
    formatearTiempoRelativo(fecha) {
        const ahora = new Date();
        const fechaNotif = new Date(fecha);
        const difMinutos = Math.floor((ahora - fechaNotif) / (1000 * 60));

        if (difMinutos < 1) return 'Ahora';
        if (difMinutos < 60) return `${difMinutos}m`;
        if (difMinutos < 1440) return `${Math.floor(difMinutos / 60)}h`;
        return `${Math.floor(difMinutos / 1440)}d`;
    }

    obtenerIconoPorTipo(tipo) {
        const iconos = {
            seguimiento_vencido: '‚è∞',
            oportunidad_alto_valor: 'üí∞',
            nuevo_prospecto: 'üë§',
            marketing: 'üì¢',
            sistema: '‚öôÔ∏è',
            recordatorio: 'üìù',
            urgente: 'üö®'
        };
        return iconos[tipo] || 'üîî';
    }

    obtenerColorPorPrioridad(prioridad) {
        const colores = {
            critica: 'text-red-600',
            alta: 'text-orange-600',
            media: 'text-yellow-600',
            baja: 'text-blue-600',
            normal: 'text-gray-600'
        };
        return colores[prioridad] || colores.normal;
    }
}

export default new NotificacionesService();